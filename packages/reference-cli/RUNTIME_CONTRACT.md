# Reference CLI Runtime Contract

## Core Principle

The CLI generates **disposable output** into `node_modules`.  
All generated files are **ephemeral** and must be regeneratable at any time.

**Mental model:** The CLI is a compiler. `node_modules/@reference/*` is compiled output, like `.js` from `.ts`.

## Five Invariants

### 1. node_modules Output is Write-Only

**Rule:** Never read from `node_modules/@reference/*` for business logic.

- ❌ Don't use it as source of truth
- ❌ Don't diff against it
- ❌ Don't patch it in place
- ✅ Treat it as compiled output

**Source of truth:**
- `.reference/runtime/*` (generated by CLI)
- `panda.config.ts` (consumer's config)
- CLI's `node_modules/@reference-ui/*` (bundled deps)

**NOT source of truth:**
- `node_modules/@reference/*` (disposable output)
- `node_modules/@reference-ui/system` (disposable output)

### 2. Whole-Directory Replacement Only

**Rule:** Always replace entire directories atomically.

```typescript
// CORRECT: Atomic temp-then-rename
cpSync(source, tempPath, { recursive: true })
rmSync(targetPath, { recursive: true, force: true })
renameSync(tempPath, targetPath)

// WRONG: Direct replacement (not atomic)
rmSync(targetPath)
cpSync(source, targetPath)

// WRONG: Patch in place
appendFileSync(targetPath + '/file.js', newContent)
```

**Why:** Avoid corrupt half-states if process is interrupted.

### 3. All Meaning Lives in Source

**Rule:** Semantic logic depends only on authoritative sources.

**Authoritative sources:**
- Design tokens in `@reference-ui/system` (bundled with CLI)
- Panda config in consumer's workspace
- Component templates in `@reference-ui/core` (bundled with CLI)

**Generated outputs (non-authoritative):**
- `.reference/css/*` — generated by Panda
- `.reference/runtime/system/*` — copied from Panda output
- `node_modules/@reference/core/*` — copied from CLI's bundled core

Never:
- Read from generated files to make decisions
- Use generated files as inputs to other generators
- Treat `node_modules` as stateful

### 4. Explicit Boundaries

**Rule:** Only write to designated output directories.

**Allowed writes:**
- `node_modules/@reference/*` (our namespace)
- `.reference/*` (our cache/runtime)

**Never touch:**
- Consumer's source code
- Consumer's other dependencies
- Shared/hoisted dependencies
- Anything outside our namespace

**Why:** This is our sandbox. Stay in it.

### 5. Idempotent Sync

**Rule:** Running sync multiple times produces identical results.

```bash
reference sync
reference sync  # same result
reference sync  # still same result
```

**Requirements:**
- No accumulation (don't append, replace)
- No side effects (don't mutate shared state)
- No hidden state (don't depend on previous runs)
- Deterministic output (same input → same output)

**Test:**
```typescript
const before = hashDirectory('node_modules/@reference')
runSync()
const after1 = hashDirectory('node_modules/@reference')
runSync()
const after2 = hashDirectory('node_modules/@reference')
assert(after1 === after2) // Idempotent
```

## Implementation: Copy-Only Architecture

### Decision

**Use direct copies, not symlinks.**

### Rationale

| Concern | Symlinks | Copies |
|---------|----------|--------|
| **Platform compatibility** | Windows admin mode required | Works everywhere |
| **Docker/containers** | Breaks with bind mounts | Just works |
| **CI environments** | Permission issues common | No permission issues |
| **Debugging** | Follow links manually | `ls -la` shows real files |
| **Mental model** | Indirection | Direct output |

### Trade-Offs Accepted

1. **Duplication**
   - Cost: Source + copy in `node_modules`
   - Mitigation: One-way flow (source → output only)
   - Impact: Minimal (JS/CSS, not gigabytes)

2. **Regeneration speed**
   - Cost: Copying is slower than symlinking
   - Reality: Milliseconds for our use case
   - Impact: Rounding error vs Panda codegen/bundling

3. **Requires discipline**
   - Cost: Must enforce invariants above
   - Mitigation: This contract + code reviews
   - Impact: Team education, automation

### What We Don't Support

- ❌ In-place edits to generated files
- ❌ Preserving modifications to `node_modules/@reference`
- ❌ Symlink-based development workflows
- ❌ Incremental updates (always full replacement)

## File System Layout

### Consumer's Project
```
consumer-app/
├── .reference/
│   ├── css/                      # Generated by Panda
│   │   ├── index.js
│   │   └── css.js
│   └── runtime/
│       ├── core/                 # Built by CLI
│       │   ├── index.mjs
│       │   ├── react.mjs
│       │   ├── styles.css
│       │   └── package.json
│       └── system/               # Built by CLI
│           ├── css/              # Copy of .reference/css
│           └── package.json
├── node_modules/
│   ├── @reference/
│   │   └── core/                 # Generated package (COPIED)
│   │       ├── node_modules/
│   │       │   ├── @reference-ui/
│   │       │   │   └── system/   # COPIED from .reference/runtime/system
│   │       │   ├── lit/          # COPIED from CLI's node_modules/lit
│   │       │   └── @lit/
│   │       │       └── react/    # COPIED from CLI's node_modules/@lit/react
│   │       ├── index.mjs
│   │       ├── react.mjs
│   │       ├── styles.css
│   │       └── package.json
│   └── @reference-ui/
│       └── system/               # COPIED from .reference/runtime/system (for top-level imports)
├── panda.config.ts               # Consumer's config (source of truth)
└── src/
    └── App.tsx
```

### Data Flow

```
Consumer's Config
       ↓
   [Panda Codegen]
       ↓
.reference/css/*  ──────→  .reference/runtime/system/
                                    ↓
CLI's Bundled Deps  ────→  .reference/runtime/core/
                                    ↓
                            [Atomic Copy]
                                    ↓
                         node_modules/@reference/core/
                                    ↓
                              (Consumer uses)
```

**One-way flow:** Source → Runtime → node_modules → Consumer

## Validation

After every sync, these must be true:

```typescript
// Core structure exists
assert(existsSync('node_modules/@reference/core/index.mjs'))
assert(existsSync('node_modules/@reference/core/react.mjs'))
assert(existsSync('node_modules/@reference/core/styles.css'))
assert(existsSync('node_modules/@reference/core/package.json'))

// Dependencies are present (as copies, not symlinks)
assert(existsSync('node_modules/@reference/core/node_modules/lit'))
assert(existsSync('node_modules/@reference/core/node_modules/@lit/react'))
assert(existsSync('node_modules/@reference/core/node_modules/@reference-ui/system'))

// Top-level system package for bundler resolution
assert(existsSync('node_modules/@reference-ui/system/css/css.js'))

// Runtime sources exist
assert(existsSync('.reference/runtime/core/index.mjs'))
assert(existsSync('.reference/runtime/system/css/css.js'))
```

## Error Handling

### Graceful Failures

**Missing CLI dependencies:**
```
Error: @reference-ui/cli: Cannot find @reference-ui/core/dist at /path/to/cli/node_modules/@reference-ui/core/dist.
Suggestion: Reinstall the CLI package.
```

**Permission denied:**
```
Error: EACCES: permission denied, mkdir 'node_modules/@reference'
Suggestion: Check directory permissions or run in a writable location.
```

**Partial sync (interrupted):**
- Atomic operations prevent this
- Temp directory is abandoned
- Next sync starts clean

### Recovery Strategy

If sync fails:
1. Remove temp directories (`node_modules/@reference/.core-*`)
2. Optionally clean `.reference/runtime/*`
3. Re-run `reference sync`

## CI/CD Requirements

### Must Work In

- ✅ GitHub Actions (Linux)
- ✅ GitLab CI (Linux)
- ✅ CircleCI
- ✅ Windows CI (no admin mode needed)
- ✅ Docker containers
- ✅ Serverless build environments (Vercel, Netlify)

### Environment Constraints

- ✅ No `sudo` required
- ✅ Works in read-only filesystems (except consumer's workspace)
- ✅ Works with `npm ci` / `pnpm install --frozen-lockfile`
- ✅ Works offline (no network after install)
- ✅ Works in sandboxed environments

## Testing Strategy

### Unit Tests

- Path resolution across platforms (Windows/Unix)
- Atomic copy operations (temp → target)
- Package.json generation
- Error handling for missing dependencies

### Integration Tests

```bash
# Test across package managers
npm install && reference sync && npm test
pnpm install && reference sync && pnpm test
yarn install && reference sync && yarn test

# Test in CI-like environment
docker run --rm -v $(pwd):/app node:18 sh -c \
  "cd /app && npm ci && npx reference sync && npm test"

# Test idempotency
reference sync
reference sync
reference sync
# Verify all three produce identical output
```

### E2E Tests

```typescript
// Create temp consumer package
// Write panda.config.ts
// Run reference sync
// Import and render components
// Verify they work correctly
```

## Comparison to Traditional Package Managers

| Feature | npm/pnpm/yarn | Reference CLI |
|---------|--------------|---------------|
| Package source | Registry (network) | Bundled with CLI |
| Installation | `npm install` | `reference sync` |
| Version resolution | Semver + lockfile | Single CLI version |
| Dependency graph | Computed from package.json | Hardcoded in CLI |
| Customization | None (pre-built) | Codegen per consumer |
| Update strategy | Update all packages | Update CLI only |

**We're building:** A specialized, single-vendor package compiler.

**We're not building:** A general-purpose package manager.

## Future-Proofing

### Watch Mode (Potential)
```typescript
// reference sync --watch
chokidar.watch('src/**/*.{ts,tsx}').on('change', () => {
  runPandaCodegen()
  buildSystemRuntime()
  copyRuntimeToNodeModules()
})
```

### Multiple Runtimes (Potential)
```typescript
// Support Bun, Deno
if (isBun) useBunAPIs()
else if (isDeno) useDenoAPIs()
else useNodeAPIs()
```

### Parallel Processing (Potential)
```typescript
await Promise.all([
  copyCore(),
  copySystem(),
  copyLit(),
  copyLitReact()
])
```

## Summary

✅ **Copy-only architecture** reduces platform edge cases and mental overhead

✅ **Atomic operations** prevent corrupt states

✅ **One-way data flow** makes the system predictable

✅ **Explicit boundaries** prevent unintended side effects

✅ **Idempotent sync** makes it safe to re-run anytime

This is not a library. This is a **compiler pipeline that happens to use npm conventions**.

And compilers copy their outputs.
