Reference Architecture — Core ↔ Gen Relationship

This document defines the precise relationship between reference-system (core) and reference-gen (compiler), and how the CLI consumes them.

This is not negotiable architecture — this is the load-bearing structure of the project.

High-level truth (lock this in)

reference-system is a source program.
reference-gen is a compiler that consumes it.

Not:

a library importing another library

a runtime dependency

a bundled artefact

This is a language/toolchain relationship, not an app dependency graph.

Module roles (corrected and precise)
1. reference-system (CORE)

Status:
✅ Source-code only
❌ Never bundled
❌ Never published as a consumable package
❌ Never imported by user code

What it is

reference-system is a pure source repository that defines:

the Reference design system program

Panda CSS configuration

token schema

component implementations (Lit)

styling semantics

layout rules

spacing rules

invariants

Think of it as:

a compiler input

a “standard library” for Reference

a design-system AST in source form

Hard rules

No bundler

No dist folder

No compiled JS output

No runtime artefacts

No node_modules consumption by users

The only generated output allowed in this repo is:

✅ Panda CSS codegen output
(because Panda itself is a compiler dependency)

That’s it.

Everything else is source.

2. reference-gen (COMPILER)

Status:
✅ Compiler backend
✅ Owns bundling
✅ Owns transforms
✅ Produces artefacts
❌ Does not define semantics

What it is

reference-gen is the design system compiler.

It:

consumes reference-system as source

watches it during development

recompiles itself when core changes

exposes a single, pure API

generateDesignSystem(config) → BuildResult

Key properties

reference-gen is tightly coupled to reference-system

They are developed together

They are not versioned independently

They may be symlinked or workspace-coupled during dev

They behave like rustc ↔ libcore

This is intentional coupling.

Critical constraint (this is important)

reference-gen must be able to consume reference-system without bundling it first.

That means:

Core is loaded as source

Parsed / analysed / transformed

Possibly executed in a controlled Node context

But never pre-bundled

This keeps:

semantics transparent

transforms explicit

debugging sane

the signal flow clean

Initial phase (you’re thinking correctly)

“Initially, to test the system, it should store core not in a bundle format but in memory.”

✅ Correct.

Phase 1: In-memory compilation

reference-gen loads reference-system source

Applies parameters (tokens, flags)

Runs Panda codegen

Produces an in-memory representation:

type BuildResult = {
  files: Map<string, string | Uint8Array>
  metadata: {
    hash
    tokensUsed
    components
  }
}


No filesystem writes.
No bundler output yet.
No dist directories.

This is the cleanest possible signal flow.

Later phase (optional, but planned)

Once semantics are stable, reference-gen may:

bundle component outputs

emit multiple targets (React, etc.)

tree-shake unused components

optimise CSS

But never at the cost of:

making core opaque

hiding semantics behind bundles

losing determinism

3. @reference-ui/cli (INTERFACE)

Status:
✅ Only public package
✅ Only thing users install

What it is

The CLI is the execution and materialisation layer.

It:

imports the ESM build of reference-gen

calls generateDesignSystem() on:

reference sync

reference build

reference dev

takes the in-memory BuildResult

writes it to disk:

.reference/ (internal)

node_modules/@reference/* (distribution snapshot)

Key invariant

The CLI is the only layer allowed to touch the filesystem.

Compiler = pure
System = semantic
CLI = side effects

Correct dependency graph
reference-system  (source only)
        ↑
        │   watches / consumes
reference-gen     (compiler)
        ↑
        │   imports ESM build
@reference-ui/cli (interface)


Notably:

Core does not depend on gen

Gen depends on core

CLI depends on gen

Users depend on CLI only

Why this matters (and why you’re right)

This structure guarantees:

Core semantics are never polluted by build concerns

Compiler logic never leaks into runtime

CLI remains boring and replaceable

Determinism is preserved

Debugging stays human-readable

The system scales to new targets

Most frontend tooling fails because it collapses these layers.

You didn’t.

Final invariant (write this somewhere prominent)

Core is source.
Gen is compiler.
CLI is I/O.
Files are output.
Semantics never move.

If you hold that line, this project will stay sharp.

If you want next, we can:

formalise how gen loads core (module graph vs AST vs eval)

define what “watching core” means concretely

or sketch how multi-target output slots in without breaking this purity

But architecturally — yes.
You’ve got the relationship exactly right.




ChatGPT can make mistakes. Check important info. See Cookie Preferences.